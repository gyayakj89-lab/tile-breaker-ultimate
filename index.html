<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Tile Breaker Ultimate</title>
<style>
body {
  margin:0;
  background: linear-gradient(to bottom, #0f2027, #203a43, #2c5364);
  overflow:hidden;
  font-family: Arial;
  text-align:center;
  color:white;
}

canvas {
  background:#111;
  display:block;
  margin:auto;
  border-radius:12px;
  box-shadow:0 0 20px cyan;
}

#menu {
  position:absolute;
  top:50%;
  left:50%;
  transform:translate(-50%,-50%);
}

button {
  padding:10px 20px;
  margin:5px;
  font-size:16px;
  border:none;
  border-radius:8px;
  cursor:pointer;
}
</style>
</head>
<body>

<div id="menu">
  <h1>Tile Breaker Ultimate</h1>
  <p>Select Difficulty</p>
  <button onclick="startGame('easy')">Easy</button>
  <button onclick="startGame('medium')">Medium</button>
  <button onclick="startGame('hard')">Hard</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

canvas.width = window.innerWidth > 800 ? 800 : window.innerWidth - 20;
canvas.height = 500;

let paddleHeight = 15;
let paddleWidth = 120;
let paddleX;
let ballRadius = 10;
let x,y,dx,dy;
let rightPressed=false;
let leftPressed=false;
let score=0;
let lives=3;
let level=1;
let gameStarted=false;
let paused=false;

let brickRowCount;
let brickColumnCount=8;
let brickWidth=75;
let brickHeight=20;
let brickPadding=10;
let brickOffsetTop=60;
let brickOffsetLeft=30;
let bricks=[];

let powerUps=[];

function startGame(difficulty){
  document.getElementById("menu").style.display="none";
  
  if(difficulty==="easy"){ brickRowCount=3; lives=5; }
  if(difficulty==="medium"){ brickRowCount=5; lives=3; }
  if(difficulty==="hard"){ brickRowCount=7; lives=2; }

  resetGame();
  gameStarted=true;
  draw();
}

function resetGame(){
  paddleX=(canvas.width-paddleWidth)/2;
  x=canvas.width/2;
  y=canvas.height-30;
  dx=4;
  dy=-4;
  createBricks();
}

function createBricks(){
  bricks=[];
  for(let c=0;c<brickColumnCount;c++){
    bricks[c]=[];
    for(let r=0;r<brickRowCount;r++){
      bricks[c][r]={x:0,y:0,status:1};
    }
  }
}

document.addEventListener("keydown", e=>{
  if(e.key==="Right"||e.key==="ArrowRight") rightPressed=true;
  if(e.key==="Left"||e.key==="ArrowLeft") leftPressed=true;
  if(e.key==="p") paused=!paused;
});
document.addEventListener("keyup", e=>{
  if(e.key==="Right"||e.key==="ArrowRight") rightPressed=false;
  if(e.key==="Left"||e.key==="ArrowLeft") leftPressed=false;
});

canvas.addEventListener("mousemove", e=>{
  let relativeX = e.clientX - canvas.offsetLeft;
  if(relativeX>0 && relativeX<canvas.width){
    paddleX = relativeX - paddleWidth/2;
  }
});

function drawPaddle(){
  ctx.beginPath();
  ctx.roundRect(paddleX, canvas.height-paddleHeight-10, paddleWidth, paddleHeight, 10);
  ctx.fillStyle="cyan";
  ctx.fill();
  ctx.closePath();
}

function drawBall(){
  ctx.beginPath();
  ctx.arc(x,y,ballRadius,0,Math.PI*2);
  ctx.fillStyle="white";
  ctx.fill();
  ctx.closePath();
}

function drawBricks(){
  for(let c=0;c<brickColumnCount;c++){
    for(let r=0;r<brickRowCount;r++){
      if(bricks[c][r].status==1){
        let brickX=(c*(brickWidth+brickPadding))+brickOffsetLeft;
        let brickY=(r*(brickHeight+brickPadding))+brickOffsetTop;
        bricks[c][r].x=brickX;
        bricks[c][r].y=brickY;
        ctx.beginPath();
        ctx.roundRect(brickX,brickY,brickWidth,brickHeight,6);
        ctx.fillStyle="orange";
        ctx.fill();
        ctx.closePath();
      }
    }
  }
}

function collisionDetection(){
  for(let c=0;c<brickColumnCount;c++){
    for(let r=0;r<brickRowCount;r++){
      let b=bricks[c][r];
      if(b.status==1){
        if(x>b.x && x<b.x+brickWidth && y>b.y && y<b.y+brickHeight){
          dy=-dy;
          b.status=0;
          score++;
          if(Math.random()<0.2){
            powerUps.push({x:b.x+brickWidth/2,y:b.y,type:"expand"});
          }
          if(score==brickRowCount*brickColumnCount*level){
            level++;
            brickRowCount++;
            createBricks();
            resetGame();
          }
        }
      }
    }
  }
}

function drawPowerUps(){
  for(let i=0;i<powerUps.length;i++){
    let p=powerUps[i];
    p.y+=2;
    ctx.beginPath();
    ctx.arc(p.x,p.y,8,0,Math.PI*2);
    ctx.fillStyle="lime";
    ctx.fill();
    ctx.closePath();

    if(p.y>canvas.height-paddleHeight-10 && 
       p.x>paddleX && p.x<paddleX+paddleWidth){
        paddleWidth+=30;
        powerUps.splice(i,1);
    }
  }
}

function draw(){
  if(!gameStarted) return;
  if(paused){
    ctx.fillStyle="white";
    ctx.fillText("Paused",canvas.width/2-30,canvas.height/2);
    requestAnimationFrame(draw);
    return;
  }

  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawBricks();
  drawBall();
  drawPaddle();
  drawPowerUps();
  collisionDetection();

  ctx.fillText("Score: "+score,8,20);
  ctx.fillText("Lives: "+lives,canvas.width-70,20);
  ctx.fillText("Level: "+level,canvas.width/2-30,20);

  if(x+dx>canvas.width-ballRadius||x+dx<ballRadius) dx=-dx;
  if(y+dy<ballRadius) dy=-dy;
  else if(y+dy>canvas.height-ballRadius-10){
    if(x>paddleX && x<paddleX+paddleWidth){
      dy=-dy;
    } else {
      lives--;
      if(!lives){
        alert("GAME OVER");
        document.location.reload();
      } else {
        resetGame();
      }
    }
  }

  if(rightPressed && paddleX<canvas.width-paddleWidth) paddleX+=7;
  else if(leftPressed && paddleX>0) paddleX-=7;

  x+=dx;
  y+=dy;

  requestAnimationFrame(draw);
}
</script>
</body>
</html>
